[
  {
    "conversations": [
      {
        "from": "human",
        "value": "Rust'ta ownership nedir"
      },
      {
        "from": "jessy",
        "value": "I think ownership Rust'ın en güçlü özelliği. Her value'nun tek bir owner'ı var. Owner scope dışına çıkınca memory otomatik temizlenir. Bu compile-time'da kontrol edilir, runtime overhead yok.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 3,
          "category": "rust"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Borrowing nasıl çalışır"
      },
      {
        "from": "jessy",
        "value": "Borrowing geçici erişim sağlar. İki tür var: immutable (&T) - birden fazla olabilir, mutable (&mut T) - tek bir tane. Compiler borrow checker ile data race'leri compile-time'da önler.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "rust"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Move semantics ne demek"
      },
      {
        "from": "jessy",
        "value": "Move ownership'i transfer eder. Value yeni owner'a geçer, eski owner artık kullanamaz. Copy trait yoksa default behavior move'dur. Bu memory safety garantisi verir.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 3,
          "category": "rust"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Lifetime nedir"
      },
      {
        "from": "jessy",
        "value": "Lifetime reference'ların ne kadar yaşayacağını belirtir. Compiler borrow checker için gerekli. Dangling pointer'ları compile-time'da önler. Çoğu zaman compiler infer eder, bazen explicit yazman gerekir.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "rust"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Clone vs Copy farkı"
      },
      {
        "from": "jessy",
        "value": "Copy implicit, cheap (stack-only). Clone explicit, expensive olabilir (heap allocation). Copy trait olan tipler otomatik kopyalanır. Clone trait manuel çağrılır.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 2,
          "category": "rust"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Result ve Option ne zaman kullanılır"
      },
      {
        "from": "jessy",
        "value": "Result error handling için - Ok(value) veya Err(error). Option nullable değerler için - Some(value) veya None. ? operator ile early return yapabilirsin. Panic yerine Result kullan.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 3,
          "category": "rust"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Trait nedir"
      },
      {
        "from": "jessy",
        "value": "Trait shared behavior tanımlar. Interface gibi ama daha güçlü. Default implementation verebilirsin. Blanket implementation yapabilirsin. Trait bounds ile generic constraints tanımlarsın.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "rust"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Async/await nasıl çalışır"
      },
      {
        "from": "jessy",
        "value": "Async function Future döner. Await ile beklersin. Behind the scenes state machine var. Tokio gibi runtime gerekir. Non-blocking I/O için kullanılır.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "rust"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Arc ve Mutex ne zaman kullanılır"
      },
      {
        "from": "jessy",
        "value": "Arc shared ownership için (thread-safe reference counting). Mutex interior mutability için (thread-safe mutable access). Birlikte kullanılır: Arc<Mutex<T>>. RwLock read-heavy workload için daha iyi.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "rust"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Unsafe ne zaman kullanmalıyım"
      },
      {
        "from": "jessy",
        "value": "Unsafe son çare. Raw pointer, FFI, inline assembly için gerekli. Safety invariants sen garanti etmelisin. Minimal unsafe block kullan, safe abstraction yap üstüne.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "rust"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Macro nedir"
      },
      {
        "from": "jessy",
        "value": "Macro code generation yapar compile-time'da. Declarative (macro_rules!) ve procedural (derive, attribute) var. Boilerplate azaltır ama debug zor. Dikkatli kullan.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "rust"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Smart pointer'lar nelerdir"
      },
      {
        "from": "jessy",
        "value": "Box (heap allocation), Rc (reference counting), Arc (atomic RC), RefCell (runtime borrow check), Mutex (thread-safe interior mutability). Her birinin use case'i farklı.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 3,
          "category": "rust"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Pattern matching nasıl kullanılır"
      },
      {
        "from": "jessy",
        "value": "Match expression exhaustive olmalı. Destructuring yapabilirsin. Guard clause ekleyebilirsin. if let, while let shorthand'ler var. Compiler missing pattern'leri yakalar.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 3,
          "category": "rust"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Error handling best practices"
      },
      {
        "from": "jessy",
        "value": "Result kullan, panic kullanma (library code'da). ? operator ile propagate et. Custom error types tanımla. thiserror crate yardımcı. Context ekle (anyhow).",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "rust"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Cargo workspace nedir"
      },
      {
        "from": "jessy",
        "value": "Monorepo için. Birden fazla crate tek workspace'te. Shared dependencies. Tek Cargo.lock. cargo build --workspace ile hepsini build edersin.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 3,
          "category": "rust"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Test nasıl yazılır"
      },
      {
        "from": "jessy",
        "value": "#[test] attribute kullan. assert!, assert_eq! macro'ları var. #[should_panic] expected panic için. Integration tests tests/ folder'da. cargo test ile çalıştır.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 3,
          "category": "rust"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Benchmark nasıl yapılır"
      },
      {
        "from": "jessy",
        "value": "Criterion crate kullan. benches/ folder'da. cargo bench ile çalıştır. Flamegraph ile profile et. Micro-benchmark'lar misleading olabilir.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "rust"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "FFI nasıl yapılır"
      },
      {
        "from": "jessy",
        "value": "extern \"C\" ile C ABI kullan. #[repr(C)] struct'lar için. Unsafe block gerekir. cbindgen Rust → C header generate eder. bindgen C → Rust binding generate eder.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 5,
          "category": "rust"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Const vs static farkı"
      },
      {
        "from": "jessy",
        "value": "Const compile-time constant, inline edilir. Static runtime'da tek instance, memory address var. Static mut unsafe. Const generic'lerde kullanılabilir.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 3,
          "category": "rust"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Closure nasıl çalışır"
      },
      {
        "from": "jessy",
        "value": "Closure environment capture eder. Fn, FnMut, FnOnce trait'leri var. Move keyword ownership transfer eder. Compiler otomatik trait seçer.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "rust"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Iterator pattern"
      },
      {
        "from": "jessy",
        "value": "Iterator trait implement et. next() method gerekli. Lazy evaluation. Combinator'lar (map, filter, fold) var. collect() ile consume edersin.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "rust"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Zero-cost abstraction nedir"
      },
      {
        "from": "jessy",
        "value": "Abstraction runtime overhead eklemez. Compiler optimize eder. Iterator örneği: for loop kadar hızlı. Rust'ın core principle'ı.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 3,
          "category": "rust"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Phantom types nedir"
      },
      {
        "from": "jessy",
        "value": "Type-level programming için. Runtime'da yer kaplamaz. State machine'lerde kullanılır. PhantomData<T> marker type.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 5,
          "category": "rust"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Newtype pattern"
      },
      {
        "from": "jessy",
        "value": "Tuple struct ile type safety. Orphan rule bypass eder. Trait implementation için. Zero-cost abstraction.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 3,
          "category": "rust"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Builder pattern Rust'ta"
      },
      {
        "from": "jessy",
        "value": "Method chaining. self döndür. build() final method. derive_builder crate otomatik generate eder.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 3,
          "category": "rust"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "RAII nedir"
      },
      {
        "from": "jessy",
        "value": "Resource Acquisition Is Initialization. Drop trait otomatik cleanup. File, socket, lock otomatik release. Rust'ın core pattern'i.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 3,
          "category": "rust"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Interior mutability"
      },
      {
        "from": "jessy",
        "value": "RefCell, Cell, Mutex, RwLock. Immutable reference ile mutable access. Runtime borrow check. Dikkatli kullan.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "rust"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Deref coercion"
      },
      {
        "from": "jessy",
        "value": "Deref trait automatic conversion. &String → &str gibi. Smart pointer'lar için. Compiler otomatik yapar.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 3,
          "category": "rust"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Sized trait"
      },
      {
        "from": "jessy",
        "value": "Compile-time size bilinen tipler. ?Sized unsized types için. Slice, trait object unsized. Generic'lerde implicit Sized bound var.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "rust"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Send ve Sync traits"
      },
      {
        "from": "jessy",
        "value": "Send: ownership thread'ler arası transfer edilebilir. Sync: reference thread-safe. Compiler otomatik implement eder. Unsafe impl gerekirse dikkatli ol.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "rust"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Microservices mi monolith mi"
      },
      {
        "from": "jessy",
        "value": "I believe context-dependent. Monolith first: team < 10, MVP stage, domain unclear. Microservices when: team > 20, domain boundaries clear, independent scaling needed. Modular monolith good middle ground.",
        "metadata": {
          "complexity": "HIGH",
          "iterations": 7,
          "category": "architecture"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "SOLID prensipleri nedir"
      },
      {
        "from": "jessy",
        "value": "Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion. Ama dogma değil - pragmatik kullan. Rust'ta trait system SOLID'i doğal yapar.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "architecture"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "DDD nedir"
      },
      {
        "from": "jessy",
        "value": "Domain-Driven Design. Domain model merkezi. Ubiquitous language kullan. Bounded contexts tanımla. Aggregate'ler consistency boundary. Event sourcing optional.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 5,
          "category": "architecture"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Event sourcing ne zaman kullanılır"
      },
      {
        "from": "jessy",
        "value": "Audit trail gerektiğinde. Time travel istediğinde. Complex domain logic varsa. Ama complexity ekler - basit CRUD için overkill.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "architecture"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "CQRS nedir"
      },
      {
        "from": "jessy",
        "value": "Command Query Responsibility Segregation. Read ve write model'leri ayır. Read optimize et (denormalize), write consistency garantile. Event sourcing ile iyi çalışır.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "architecture"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Hexagonal architecture nedir"
      },
      {
        "from": "jessy",
        "value": "Ports and adapters. Domain logic merkezi, infrastructure dışarıda. Dependency inversion. Test edilebilir. Clean architecture benzeri.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 5,
          "category": "architecture"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Repository pattern"
      },
      {
        "from": "jessy",
        "value": "Data access abstraction. Domain logic'ten infrastructure'ı ayırır. Interface tanımla, implementation inject et. Test için mock'lanabilir.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "architecture"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Factory pattern ne zaman kullanılır"
      },
      {
        "from": "jessy",
        "value": "Complex object creation. Multiple constructors yerine. Builder pattern alternatif. Rust'ta associated function kullan.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 3,
          "category": "architecture"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Dependency injection"
      },
      {
        "from": "jessy",
        "value": "Dependencies dışarıdan inject et. Tight coupling önler. Test edilebilir. Rust'ta trait object veya generic kullan.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "architecture"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "API versioning strategi"
      },
      {
        "from": "jessy",
        "value": "URL versioning (/v1/), header versioning, content negotiation. Breaking change'lerde yeni version. Deprecation policy tanımla.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "architecture"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "REST vs GraphQL"
      },
      {
        "from": "jessy",
        "value": "REST simple, cacheable, well-understood. GraphQL flexible, single endpoint, overfetching önler. Use case'e göre seç.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "architecture"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Database sharding"
      },
      {
        "from": "jessy",
        "value": "Horizontal partitioning. Scale out için. Shard key önemli. Rebalancing zor. Consistent hashing yardımcı.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 5,
          "category": "architecture"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "CAP theorem"
      },
      {
        "from": "jessy",
        "value": "Consistency, Availability, Partition tolerance - pick 2. Distributed system'lerde trade-off. CP veya AP seç.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 5,
          "category": "architecture"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Eventual consistency"
      },
      {
        "from": "jessy",
        "value": "Strong consistency yerine. Distributed system'lerde. CRDT'ler yardımcı. Conflict resolution gerekir.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 5,
          "category": "architecture"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Circuit breaker pattern"
      },
      {
        "from": "jessy",
        "value": "Failure cascade önler. Threshold'dan sonra circuit open. Timeout sonra half-open. Retry logic ekle.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "architecture"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Rate limiting"
      },
      {
        "from": "jessy",
        "value": "Token bucket, leaky bucket, fixed window, sliding window. DDoS önler. API quota için. Redis ile implement edilir.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "architecture"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Caching strategi"
      },
      {
        "from": "jessy",
        "value": "Cache-aside, write-through, write-behind. TTL tanımla. Invalidation zor. Redis, Memcached kullan.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "architecture"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Message queue ne zaman kullanılır"
      },
      {
        "from": "jessy",
        "value": "Async processing. Decoupling. Load leveling. Retry logic. RabbitMQ, Kafka, SQS.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "architecture"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Saga pattern"
      },
      {
        "from": "jessy",
        "value": "Distributed transaction. Compensating transaction. Choreography vs orchestration. Event-driven.",
        "metadata": {
          "complexity": "HIGH",
          "iterations": 6,
          "category": "architecture"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "API gateway"
      },
      {
        "from": "jessy",
        "value": "Single entry point. Authentication, rate limiting, routing. Kong, Nginx, Envoy.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 3,
          "category": "architecture"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Service mesh"
      },
      {
        "from": "jessy",
        "value": "Sidecar proxy. Service discovery, load balancing, observability. Istio, Linkerd. Complexity ekler.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 5,
          "category": "architecture"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Blue-green deployment"
      },
      {
        "from": "jessy",
        "value": "Zero downtime. Two identical environments. Switch traffic. Rollback kolay.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 3,
          "category": "architecture"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Canary deployment"
      },
      {
        "from": "jessy",
        "value": "Gradual rollout. Monitor metrics. Rollback if issues. Feature flags ile combine edilir.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "architecture"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Feature flags"
      },
      {
        "from": "jessy",
        "value": "Runtime feature toggle. A/B testing. Gradual rollout. Kill switch. LaunchDarkly, Unleash.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 3,
          "category": "architecture"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Observability"
      },
      {
        "from": "jessy",
        "value": "Metrics, logs, traces. Prometheus, Grafana, Jaeger. SLO, SLI, SLA tanımla.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "architecture"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Idempotency"
      },
      {
        "from": "jessy",
        "value": "Same request, same result. Retry-safe. Idempotency key kullan. POST, PUT, DELETE için önemli.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "architecture"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Backward compatibility"
      },
      {
        "from": "jessy",
        "value": "API contract koruma. Versioning. Deprecation. Breaking change minimize et.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "architecture"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Schema evolution"
      },
      {
        "from": "jessy",
        "value": "Database schema değişimi. Migration. Backward compatible. Avro, Protobuf schema registry.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 5,
          "category": "architecture"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Distributed tracing"
      },
      {
        "from": "jessy",
        "value": "Request flow tracking. Span, trace. Jaeger, Zipkin. Correlation ID.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "architecture"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Load balancing"
      },
      {
        "from": "jessy",
        "value": "Round robin, least connections, IP hash. L4 vs L7. Health check. Nginx, HAProxy.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "architecture"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Performans nasıl optimize ederim"
      },
      {
        "from": "jessy",
        "value": "First: profile! Measure before optimizing. Flamegraph kullan, bottleneck'leri bul. Then: 1) Algorithm optimize et, 2) Allocations azalt, 3) Cache ekle, 4) Parallel yap. Premature optimization yapma.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 5,
          "category": "performance"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Memory leak nasıl bulunur"
      },
      {
        "from": "jessy",
        "value": "Valgrind (C/C++), heaptrack, memory profiler kullan. Rust'ta leak zor ama mümkün: Rc cycle, forget(), static lifetime. Drop trait implement et, RAII kullan.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "performance"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Cache-friendly kod nasıl yazılır"
      },
      {
        "from": "jessy",
        "value": "Sequential access > random access. Struct of arrays > array of structs (data-oriented design). Prefetching yardımcı olur. Cache line size (64 bytes) önemli.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 5,
          "category": "performance"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Lock-free programming nedir"
      },
      {
        "from": "jessy",
        "value": "Atomic operations kullan, lock kullanma. Compare-and-swap (CAS) temel. Ordering önemli: Relaxed, Acquire, Release, SeqCst. Zor ama performanslı.",
        "metadata": {
          "complexity": "HIGH",
          "iterations": 6,
          "category": "performance"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Zero-copy nedir"
      },
      {
        "from": "jessy",
        "value": "Data kopyalamadan transfer et. MMAP, sendfile, splice kullan. Rust'ta slice reference zero-copy. Ownership system zero-copy'yi güvenli yapar.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 3,
          "category": "performance"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "SIMD nedir"
      },
      {
        "from": "jessy",
        "value": "Single Instruction Multiple Data. Vectorization. Parallel data processing. Rust'ta std::simd veya packed_simd. Auto-vectorization compiler yapar.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 5,
          "category": "performance"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Branch prediction"
      },
      {
        "from": "jessy",
        "value": "CPU branch'leri predict eder. Misprediction pahalı. Predictable branch'ler hızlı. Profile-guided optimization yardımcı.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 5,
          "category": "performance"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Memory alignment"
      },
      {
        "from": "jessy",
        "value": "Data alignment performance etkiler. Unaligned access slow. #[repr(C)] veya #[repr(align(N))] kullan. Padding ekler.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "performance"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "False sharing"
      },
      {
        "from": "jessy",
        "value": "Cache line sharing. Different threads, same cache line. Performance killer. Padding ekle, separate cache lines.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 5,
          "category": "performance"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Allocation strategies"
      },
      {
        "from": "jessy",
        "value": "Stack > heap. Arena allocator batch allocation. Pool allocator reuse. Custom allocator implement edebilirsin.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "performance"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Lazy evaluation"
      },
      {
        "from": "jessy",
        "value": "Compute on demand. Iterator lazy. Memoization cache eder. Trade-off: memory vs computation.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "performance"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Parallel processing"
      },
      {
        "from": "jessy",
        "value": "Rayon crate data parallelism için. par_iter() kullan. Work stealing. CPU-bound tasks için.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "performance"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Async I/O"
      },
      {
        "from": "jessy",
        "value": "Non-blocking I/O. Tokio, async-std. Event loop. I/O-bound tasks için. CPU-bound için thread pool.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "performance"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Database query optimization"
      },
      {
        "from": "jessy",
        "value": "Index kullan. N+1 query önle. Batch query. Connection pooling. Explain plan analiz et.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 5,
          "category": "performance"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Compression"
      },
      {
        "from": "jessy",
        "value": "CPU vs bandwidth trade-off. LZ4 fast, Zstd balanced, Brotli high compression. Use case'e göre seç.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "performance"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Serialization performance"
      },
      {
        "from": "jessy",
        "value": "Bincode > JSON > MessagePack. Zero-copy deserialization (serde_zero_copy). Schema evolution consider et.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "performance"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Network optimization"
      },
      {
        "from": "jessy",
        "value": "TCP_NODELAY disable Nagle. Keep-alive connection reuse. HTTP/2 multiplexing. gRPC binary protocol.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 5,
          "category": "performance"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Profiling tools"
      },
      {
        "from": "jessy",
        "value": "perf, flamegraph, valgrind, heaptrack. Rust: cargo-flamegraph, criterion. Profile production-like load.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "performance"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Benchmark methodology"
      },
      {
        "from": "jessy",
        "value": "Warm-up runs. Multiple iterations. Statistical significance. Isolate variables. Document environment.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 5,
          "category": "performance"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Optimization priorities"
      },
      {
        "from": "jessy",
        "value": "1) Algorithm complexity, 2) Data structures, 3) Memory access patterns, 4) Micro-optimizations. Measure impact.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 5,
          "category": "performance"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Segfault nasıl debug ederim"
      },
      {
        "from": "jessy",
        "value": "GDB kullan: gdb ./program, run, backtrace. Core dump enable et. AddressSanitizer kullan. Rust'ta segfault nadirdir - unsafe block'lara bak.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "debugging"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Race condition nasıl bulunur"
      },
      {
        "from": "jessy",
        "value": "ThreadSanitizer kullan. Helgrind (Valgrind). Rust'ta borrow checker çoğu race'i önler. Ama logic race'ler mümkün - test et.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "debugging"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Memory corruption nasıl debug ederim"
      },
      {
        "from": "jessy",
        "value": "AddressSanitizer, Valgrind. Rust'ta nadir - unsafe block'lara bak. Buffer overflow, use-after-free, double-free kontrol et.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "debugging"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Deadlock nasıl önlenir"
      },
      {
        "from": "jessy",
        "value": "Lock ordering kullan. Timeout ekle. Try_lock kullan. Rust'ta Mutex poisoning var. RwLock read-heavy için daha iyi.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "debugging"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Performance regression nasıl bulunur"
      },
      {
        "from": "jessy",
        "value": "Benchmark her commit'te. Flamegraph compare et. Git bisect kullan. Continuous benchmarking setup yap.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "debugging"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Heisenbug nedir"
      },
      {
        "from": "jessy",
        "value": "Observe ettiğinde kaybolur. Timing-dependent. Race condition, uninitialized memory. Logging eklemek değiştirir. Zor debug.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 5,
          "category": "debugging"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Stack overflow nasıl debug ederim"
      },
      {
        "from": "jessy",
        "value": "Backtrace bak. Recursive function check et. Stack size artır (ulimit). Tail recursion optimize et. Iteration'a çevir.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "debugging"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Memory leak detection"
      },
      {
        "from": "jessy",
        "value": "Valgrind memcheck. Heaptrack. Rust: cargo-leak. Rc cycle check et. Drop trait verify et.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "debugging"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Undefined behavior"
      },
      {
        "from": "jessy",
        "value": "Rust'ta nadir. Unsafe block'larda mümkün. Miri tool detect eder. Sanitizer'lar kullan.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 5,
          "category": "debugging"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Panic vs error"
      },
      {
        "from": "jessy",
        "value": "Panic unrecoverable. Error recoverable. Library panic etmemeli. Result döndür. Panic test'lerde ok.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 3,
          "category": "debugging"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Logging best practices"
      },
      {
        "from": "jessy",
        "value": "Structured logging. Log levels (trace, debug, info, warn, error). Context ekle. Performance impact consider et.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "debugging"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Debugging async code"
      },
      {
        "from": "jessy",
        "value": "Tokio-console kullan. Tracing crate. Deadlock detection. Task spawn tracking. Backtrace zor.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 5,
          "category": "debugging"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Integration test debugging"
      },
      {
        "from": "jessy",
        "value": "Isolate test. Mock dependencies. Check test data. Verify setup/teardown. Flaky test fix et.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "debugging"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Production debugging"
      },
      {
        "from": "jessy",
        "value": "Metrics, logs, traces. Correlation ID. Error tracking (Sentry). Feature flags rollback. Canary deployment.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 5,
          "category": "debugging"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Memory profiler kullanımı"
      },
      {
        "from": "jessy",
        "value": "Heaptrack, massif (Valgrind). Allocation hotspots bul. Lifetime analiz et. Unnecessary clone'ları bul.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "debugging"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "CPU profiler kullanımı"
      },
      {
        "from": "jessy",
        "value": "perf record, perf report. Flamegraph generate et. Hot functions identify et. Sampling vs instrumentation.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "debugging"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Network debugging"
      },
      {
        "from": "jessy",
        "value": "tcpdump, Wireshark. curl -v verbose. strace system calls. Connection timeout, DNS issues check et.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "debugging"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Database debugging"
      },
      {
        "from": "jessy",
        "value": "Slow query log. Explain plan. Index usage. Connection pool exhaustion. Lock contention.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "debugging"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Docker debugging"
      },
      {
        "from": "jessy",
        "value": "docker logs, docker exec. Health check verify et. Resource limits check et. Network connectivity test et.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 3,
          "category": "debugging"
        }
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Git bisect kullanımı"
      },
      {
        "from": "jessy",
        "value": "Regression find et. git bisect start, good, bad. Automated test ile. Binary search commits.",
        "metadata": {
          "complexity": "MEDIUM",
          "iterations": 4,
          "category": "debugging"
        }
      }
    ]
  }
]
# Implementation Plan - GPS Odometry Algorithm Refactor

## Task List

- [x] 1. Set up project structure and dependencies
  - Create `prod-xnaut-core-rewrite/rust/algorithms/` workspace with Cargo.toml
  - Create `prod-xnaut-core-rewrite/rust/algorithms/gps_odometry` crate with proper Cargo.toml
  - Add dependencies: nalgebra, rand, rand_distr, rclrs, serde, thiserror, tracing
  - Set up module structure: lib.rs, node.rs, transform.rs, noise.rs, validation.rs, config.rs, types.rs
  - Configure clippy and rustfmt settings to match existing drone driver standards
  - Structure mirrors Python `algorithms/` package for future algorithm additions (GIMP, etc.)
  - _Requirements: 8.1, 8.3_

- [x] 2. Implement core data types and configuration
  - [x] 2.1 Define common types in types.rs
    - Create type aliases for Vector3, Quaternion, UnitQuaternion using nalgebra
    - Define error types: TransformError, ValidationError, ProcessingError, NodeError
    - Implement Display and Error traits for all error types
    - Add constants for numerical thresholds (epsilon, tolerances)
    - _Requirements: 5.4, 7.1, 7.2_
  - [x] 2.2 Implement configuration structures in config.rs
    - Create GpsOdometryConfig, InputConfig, OutputConfig, NoiseConfig, CovarianceConfig structs
    - Add serde Deserialize derives for YAML loading
    - Implement validation logic for configuration parameters
    - Add default values matching Python implementation
    - Create config loading function from YAML file
    - _Requirements: 8.1, 8.2, 8.5, 5.4_
  - [x] 2.3 Write unit tests for configuration
    - Test YAML deserialization with valid config
    - Test validation logic with invalid parameters
    - Test default value initialization
    - _Requirements: 9.1_

- [x] 3. Implement quaternion transformation module
  - [x] 3.1 Implement core transformation functions in transform.rs
    - Write `validate_quaternion` function with magnitude and NaN checks
    - Write `normalize_quaternion` function using nalgebra
    - Write `validate_velocity` function with NaN handling (map vertical NaN to zero)
    - Write `transform_velocity_to_body_frame` function using quaternion conjugate and multiplication
    - Add inline documentation for all public functions
    - _Requirements: 1.1, 1.2, 1.3, 1.4, 1.5, 10.1_
  - [x] 3.2 Write comprehensive unit tests for transformations
    - Test identity quaternion (no rotation)
    - Test 90-degree rotations around X, Y, Z axes
    - Test arbitrary rotations with known results
    - Test NaN in vertical velocity (should map to zero)
    - Test NaN in horizontal velocity (should return zero vector)
    - Test zero quaternion magnitude (should return zero vector)
    - Test very small quaternion magnitude (should handle gracefully)
    - Test NaN in quaternion components (should return zero vector)
    - Validate numerical precision (tolerance 1e-6)
    - _Requirements: 9.1, 9.2, 1.1, 1.2, 1.3, 1.4, 1.5_

- [ ] 4. Implement validation module
  - [x] 4.1 Implement input validation functions in validation.rs
    - Write `validate_gps_velocity` to extract and validate Vector3 from TwistStamped
    - Write `validate_imu_orientation` to extract and validate quaternion from Imu message
    - Write `has_nan_velocity` helper function
    - Write `is_valid_quaternion` helper function
    - Add appropriate error types and logging
    - _Requirements: 1.3, 1.4, 1.5, 7.1, 7.2_
  - [x] 4.2 Write unit tests for validation
    - Test valid inputs pass through correctly
    - Test NaN detection in velocity
    - Test invalid quaternion detection
    - Test error message formatting
    - _Requirements: 9.1, 9.2_

- [ ] 5. Implement noise generator module
  - [ ] 5.1 Implement Gaussian noise generator in noise.rs
    - Create NoiseConfig struct with mean, std, scale parameters
    - Create NoiseGenerator struct with ThreadRng
    - Implement `new` constructor
    - Implement `generate_xy_noise` using Normal distribution
    - Implement `generate_z_noise` using Normal distribution
    - Implement `apply_noise` to modify velocity vector in-place
    - _Requirements: 3.1, 3.2, 3.3, 3.4, 3.5_
  - [ ] 5.2 Write unit tests for noise generation
    - Test statistical properties (mean, std dev) over many samples
    - Test XY vs Z noise separation
    - Test scale factor application
    - Test conditional application (apply_xy, apply_z flags)
    - _Requirements: 9.1_

- [ ] 6. Implement message synchronization
  - [ ] 6.1 Create message synchronizer in node.rs
    - Define MessageSynchronizer struct with VecDeque for both message types
    - Implement `add_message1` and `add_message2` methods
    - Implement `find_synchronized_pair` with time tolerance matching
    - Add queue size limits to prevent unbounded growth
    - Add logging for dropped messages
    - _Requirements: 2.1, 2.2, 2.3_
  - [ ] 6.2 Write unit tests for message synchronization
    - Test exact timestamp matching
    - Test approximate matching within tolerance
    - Test queue overflow handling
    - Test message dropping for old messages
    - _Requirements: 9.1_

- [ ] 7. Implement ROS2 node
  - [ ] 7.1 Create GpsOdometryNode struct in node.rs
    - Define node structure with subscribers, publisher, config, noise generator
    - Implement `new` constructor with ROS2 node initialization
    - Create subscribers for GPS velocity and IMU topics
    - Create publisher for odometry topic
    - Initialize message synchronizer
    - Integrate with error manager and performance monitor
    - _Requirements: 2.1, 2.2, 5.1, 5.2, 7.3, 7.4_
  - [ ] 7.2 Implement message processing pipeline
    - Write GPS velocity callback to add message to synchronizer
    - Write IMU callback to add message to synchronizer
    - Write `synchronized_callback` to process matched message pairs
    - Write `process_messages` to perform transformation and noise application
    - Write `build_odometry_message` to construct output message
    - Add error handling and logging throughout
    - _Requirements: 2.3, 2.4, 2.5, 4.1, 4.2, 4.3, 4.4, 4.5_
  - [ ] 7.3 Implement diagnostics and error reporting
    - Add diagnostic status publishing
    - Track processing rate, error count, NaN count
    - Integrate with centralized error management
    - Add warning logs for NaN values
    - Add error logs for repeated failures
    - Escalate diagnostic level on repeated errors
    - _Requirements: 7.1, 7.2, 7.3, 7.4, 7.5_
  - [ ] 7.4 Write integration tests for ROS2 node
    - Test node initialization and configuration loading
    - Test message subscription and publishing
    - Test synchronized callback execution
    - Test diagnostic message publishing
    - _Requirements: 9.3_

- [ ] 8. Implement backward compatibility layer
  - [ ] 8.1 Create compatibility constants
    - Define default topic names matching Python implementation
    - Define default parameter values matching Python
    - Create compatibility module with topic name constants
    - _Requirements: 5.1, 5.2, 5.3, 5.4_
  - [ ] 8.2 Implement Python compatibility validation
    - Create test vector generation script in Python
    - Generate test cases with known inputs and outputs from Python implementation
    - Save test vectors to JSON file
    - Create Rust test to load and validate against test vectors
    - Verify numerical equivalence within 1e-6 tolerance
    - _Requirements: 5.5, 9.3, 9.5_

- [ ] 9. Create configuration and launch files
  - [ ] 9.1 Create YAML configuration file
    - Create `prod-xnaut-core-rewrite/config/gps_odometry.yaml`
    - Set topic names matching Python implementation
    - Set default noise parameters
    - Set default covariance values
    - Add comments explaining each parameter
    - _Requirements: 8.1, 5.1, 5.2, 5.3, 5.4_
  - [ ] 9.2 Create launch file
    - Create `prod-xnaut-core-rewrite/launch/gps_odometry.launch.py`
    - Load configuration from YAML file
    - Set node name matching Python implementation
    - Add launch arguments for configuration overrides
    - Add comments and documentation
    - _Requirements: 8.3, 8.4_
  - [ ] 9.3 Create hybrid side-by-side launch file
    - Create launch file to run both Python and Rust implementations
    - Use unique node names to avoid conflicts
    - Publish to different output topics for comparison
    - Add validation node to compare outputs in real-time
    - _Requirements: 5.5, 9.3_

- [ ] 10. Implement performance benchmarks
  - [ ] 10.1 Create latency benchmarks
    - Create `benches/odometry_bench.rs` using criterion
    - Benchmark single message pair processing
    - Benchmark transformation only (no ROS2 overhead)
    - Benchmark with and without noise generation
    - Measure execution time variance
    - _Requirements: 6.1, 6.2, 9.4_
  - [ ] 10.2 Create comparison benchmarks
    - Create script to benchmark Python implementation
    - Run same test cases through both implementations
    - Compare latency (target: 2x improvement)
    - Compare throughput
    - Compare CPU usage
    - Generate comparison report
    - _Requirements: 6.5, 9.4, 9.5_
  - [ ] 10.3 Create memory profiling
    - Verify zero runtime allocations in hot path
    - Measure total memory usage
    - Compare with Python memory usage
    - _Requirements: 6.3, 6.4_

- [ ] 11. Create comprehensive documentation
  - [ ] 11.1 Create README
    - Write overview of GPS odometry system
    - Document coordinate frame conventions (ENU, body frame)
    - Explain quaternion transformation mathematics
    - Provide usage examples
    - Document configuration parameters
    - Add troubleshooting section
    - _Requirements: 10.1, 10.2, 10.3, 10.4_
  - [ ] 11.2 Create migration guide
    - Document differences from Python implementation (if any)
    - Provide step-by-step migration instructions
    - Document validation methodology
    - Add rollback procedures
    - Include performance comparison results
    - _Requirements: 10.4, 10.5_
  - [ ] 11.3 Add inline documentation
    - Document all public functions with rustdoc comments
    - Add examples in documentation
    - Document error conditions and edge cases
    - Add mathematical formulas where appropriate
    - _Requirements: 10.1, 10.3_

- [ ] 12. End-to-end validation and testing
  - [ ] 12.1 Run side-by-side validation
    - Launch hybrid side-by-side configuration
    - Publish test messages to both implementations
    - Collect output from both nodes
    - Compare outputs with validation script
    - Verify 100% compatibility (within tolerance)
    - Document any discrepancies and fix
    - _Requirements: 5.5, 9.3, 9.5_
  - [ ] 12.2 Run performance validation
    - Execute all benchmarks
    - Verify latency < 1ms target
    - Verify variance < 100Î¼s target
    - Verify 2x performance improvement over Python
    - Verify zero runtime allocations
    - Generate performance report
    - _Requirements: 6.1, 6.2, 6.3, 6.4, 6.5_
  - [ ] 12.3 Run stress testing
    - Test with high message rates (100Hz, 200Hz)
    - Test with continuous operation (24+ hours)
    - Monitor for memory leaks
    - Monitor for performance degradation
    - Test recovery from error conditions
    - _Requirements: 6.1, 6.2, 7.5_

- [ ] 13. Integration with existing system
  - [ ] 13.1 Update build system
    - Add gps_odometry crate to workspace Cargo.toml
    - Update CMakeLists.txt for ROS2 package
    - Add to CI/CD pipeline
    - _Requirements: 8.3_
  - [ ] 13.2 Update system launch files
    - Add gps_odometry node to main drone system launch file
    - Add feature flag to switch between Python and Rust
    - Update documentation for launch file changes
    - _Requirements: 8.3, 8.4_
  - [ ] 13.3 Create deployment documentation
    - Document deployment procedure
    - Document validation checklist
    - Document monitoring and alerting
    - Document rollback procedure
    - _Requirements: 10.4_

## Notes

- Tasks marked with `*` are optional testing tasks that can be skipped for faster MVP
- Each task references specific requirements from requirements.md
- Tasks are designed to be completed incrementally with validation at each step
- Side-by-side validation (task 12.1) is critical before production deployment
- Performance benchmarks (task 10) should be run on target hardware
